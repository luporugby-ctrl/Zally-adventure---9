<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zally's Prompt Hoops: Ultimate Ops Edition</title>
    <style>
        /* --- IMPORT FONTS --- */
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap');

        /* --- GLOBAL STYLES --- */
        body {
            background-color: #050505;
            color: #fff;
            font-family: 'Roboto Mono', monospace;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- ARCADE CABINET CONTAINER --- */
        #arcade-cabinet {
            position: relative;
            width: 960px;
            height: 640px;
            background: #121212;
            border: 8px solid #ff6900; /* Zalando Orange */
            box-shadow: 
                0 0 20px rgba(255, 105, 0, 0.2),
                0 0 60px rgba(255, 105, 0, 0.4),
                inset 0 0 50px #000;
            border-radius: 6px;
            overflow: hidden;
        }

        /* --- CRT SCANLINE EFFECT --- */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
        }

        canvas { display: block; }

        /* --- UI OVERLAY (HUD) --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            border-bottom: 1px solid rgba(255, 105, 0, 0.3);
        }

        .hud-score-box {
            text-align: left;
        }
        
        .hud-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #888;
            letter-spacing: 1px;
        }

        .hud-value {
            font-family: 'Teko', sans-serif;
            font-size: 42px;
            color: #ff6900;
            line-height: 0.9;
            text-shadow: 0 0 10px rgba(255, 105, 0, 0.5);
        }

        .hud-level-info {
            text-align: right;
        }

        .hud-level-title {
            font-family: 'Teko', sans-serif;
            font-size: 32px;
            color: #fff;
            text-transform: uppercase;
        }

        /* --- MODALS (Menus & Education) --- */
        .modal-overlay {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(8px);
            z-index: 200; /* Above scanlines */
            pointer-events: auto;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            width: 700px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-top: 6px solid #ff6900;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            padding: 40px;
            position: relative;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-title {
            font-family: 'Teko', sans-serif;
            font-size: 56px;
            color: #fff;
            margin: 0;
            line-height: 1;
            text-transform: uppercase;
        }

        .modal-subtitle {
            color: #ff6900;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        .modal-body {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 30px;
        }

        .highlight-text { color: #fff; font-weight: bold; }
        .orange-text { color: #ff6900; }

        /* --- CODE / PROMPT CARD --- */
        .prompt-card {
            background: #0f0f0f;
            border-left: 4px solid #ff6900;
            padding: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            color: #00ff9d; /* Terminal Green */
            margin: 20px 0;
            white-space: pre-wrap;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            position: relative;
        }

        .prompt-card::before {
            content: "GEMINI TERMINAL >_";
            position: absolute;
            top: -10px;
            left: 10px;
            background: #0f0f0f;
            padding: 0 5px;
            color: #666;
            font-size: 10px;
        }

        /* --- BUTTONS --- */
        .btn-action {
            background: #ff6900;
            color: #000;
            border: none;
            padding: 15px 50px;
            font-family: 'Teko', sans-serif;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: all 0.2s;
        }

        .btn-action:hover {
            background: #fff;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        /* --- CONTROL HINTS --- */
        .control-row {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .key-hint {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #888;
        }

        .key-cap {
            background: #333;
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            border-bottom: 2px solid #111;
            font-weight: bold;
        }

    </style>
</head>
<body>

<div id="arcade-cabinet">
    <div id="scanlines"></div>
    <canvas id="gameCanvas" width="960" height="640"></canvas>
    
    <div id="ui-layer">
        <div class="hud-header">
            <div class="hud-score-box">
                <div class="hud-label">PERFORMANCE SCORE</div>
                <div class="hud-value" id="scoreDisplay">0000</div>
            </div>
            <div class="hud-level-info">
                <div class="hud-label">CURRENT CHALLENGE</div>
                <div class="hud-level-title" id="levelDisplay">WARM UP</div>
            </div>
        </div>
    </div>

    <div id="startModal" class="modal-overlay" style="display: flex;">
        <div class="modal-content">
            <h1 class="modal-title">Zally's Prompt Hoops</h1>
            <div class="modal-subtitle">Training Simulation v4.0</div>
            
            <div class="modal-body">
                <p>Benvenuto nel programma di addestramento avanzato <strong>Zalando Ops</strong>.</p>
                <p>La tua missione è semplice: convertire l'intento in risultato. Ogni tiro rappresenta un prompt. La precisione è tutto.</p>
                <br>
                <strong class="orange-text">OBIETTIVO:</strong>
                <p>Completa 4 Livelli di difficoltà crescente per masterare le tecniche di Prompt Engineering.</p>
            </div>

            <button class="btn-action" onclick="game.startLevel(0)">ENTER COURT</button>

            <div class="control-row">
                <div class="key-hint"><span class="key-cap">SPACE</span> MIRA (ANGOLO)</div>
                <div class="key-hint"><span class="key-cap">SPACE</span> POTENZA</div>
                <div class="key-hint"><span class="key-cap">SPACE</span> TIRO</div>
            </div>
        </div>
    </div>

    <div id="levelModal" class="modal-overlay">
        <div class="modal-content">
            <h1 class="modal-title">TARGET ACQUIRED!</h1>
            <div class="modal-subtitle" id="lvl-badge">TECNICA SBLOCCATA</div>
            
            <div class="modal-body">
                <p id="lvl-desc">Descrizione tecnica...</p>
                <div class="prompt-card" id="lvl-code">Codice esempio...</div>
            </div>

            <button class="btn-action" onclick="game.nextLevel()">NEXT CHALLENGE</button>
        </div>
    </div>

</div>

<script>
/**
 * ZALLY'S PROMPT HOOPS - ENGINE V4.0
 * Features: Advanced Particles, Physics, Keyword Logic, Crowd System
 */

// --- CONFIGURATION & CONSTANTS ---
const COLORS = {
    orange: '#ff6900', 
    white: '#ffffff',
    black: '#000000',
    skyTop: '#0a0a12', // Berlin Night
    skyBot: '#1a1a2e',
    concrete: '#222222',
    gridLines: 'rgba(255, 105, 0, 0.3)'
};

const BANNERS = [
    "ACT LIKE AN OWNER",
    "FLY HIGH, DIVE DEEP",
    "THINK BIG, ACT FAST",
    "PLAY TO WIN",
    "MAKE US BETTER",
    "PROMPT IT REAL GOOD",
    "NO HALLUCINATIONS",
    "STRUCTURE IS KEY",
    "GEMINI CHAMPION"
];

// --- PHYSICS CLASSES ---

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    copy() { return new Vector(this.x, this.y); }
}

class Particle {
    constructor(x, y, type = 'confetti') {
        this.pos = new Vector(x, y);
        this.vel = new Vector((Math.random() - 0.5) * 10, (Math.random() - 2) * 10);
        this.acc = new Vector(0, 0.2); // Gravity
        this.type = type; // 'confetti', 'spark', 'text'
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
        
        if (type === 'confetti') {
            this.color = Math.random() > 0.5 ? COLORS.orange : COLORS.white;
            this.size = Math.random() * 6 + 4;
            this.rotation = Math.random() * 360;
            this.rotSpeed = (Math.random() - 0.5) * 10;
        } else if (type === 'spark') {
            this.color = '#ffff00';
            this.size = 2;
            this.vel.mult(0.5); // Slower sparks
        }
    }

    update() {
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.life -= this.decay;
        if (this.type === 'confetti') this.rotation += this.rotSpeed;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.pos.x, this.pos.y);
        
        if (this.type === 'confetti') {
            ctx.rotate(this.rotation * Math.PI / 180);
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        } else if (this.type === 'spark') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI*2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

class Floater {
    constructor(text, x, y, size = 20, color = COLORS.white) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.dy = -2;
        this.life = 60;
        this.size = size;
        this.color = color;
    }
    update() {
        this.y += this.dy;
        this.life--;
    }
    draw(ctx) {
        ctx.save();
        ctx.font = `bold ${this.size}px 'Teko'`;
        ctx.fillStyle = 'black';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillStyle = this.color;
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

// --- MAIN GAME CLASS ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        // --- ASSETS ---
        this.zallyImg = new Image();
        this.zallyImg.src = 'zally-basket.png';
        this.zallyLoaded = false;
        this.zallyImg.onload = () => { this.zallyLoaded = true; };

        // --- GAME VARIABLES ---
        this.state = 'MENU'; 
        this.levelIdx = 0;
        this.score = 0;
        this.shotsMade = 0;

        this.particles = [];
        this.floaters = [];
        this.crowdBanners = [];
        
        // Entity: Ball
        this.ball = { x: 0, y: 0, vx: 0, vy: 0, r: 15, active: false, rot: 0 };
        // Entity: Hoop
        this.hoop = { x: 800, y: 250 };
        // Entity: Player
        this.player = { x: 100, y: 470 };

        // Controls
        this.angle = 45;
        this.angleDir = 0.8; 
        this.power = 0;
        this.powerDir = 1.2;

        // Environment
        this.wind = 0;
        this.shake = 0;

        // --- LEVELS DATABASE ---
        this.levels = [
            {
                name: "LVL 1: THE MIRROR",
                tech: "FEW-SHOT PROMPTING",
                req: 1,
                dist: 500,
                wind: 0,
                desc: "Gemini è uno specchio: imita ciò che vede. Per ottenere l'output perfetto, non limitarti a chiedere. Fornisci ESEMPI concreti (Few-Shot).",
                code: "PROMPT:\n'Agisci come un analista Ops. \nEsempio 1: [Dati Grezzi] -> [Report Sintetico]\nEsempio 2: [Dati Grezzi] -> [Report Sintetico]\nOra trasforma questi nuovi dati seguendo lo stesso pattern...'"
            },
            {
                name: "LVL 2: THE ARCHITECT",
                tech: "CHAIN OF THOUGHT",
                req: 2,
                dist: 650,
                wind: 0,
                desc: "Per i compiti complessi, la logica deve essere costruita. Chiedi a Gemini di 'Pensare passo dopo passo' per evitare errori di calcolo.",
                code: "PROMPT:\n'Analizza il file allegato.\nStep 1: Isola i resi della Categoria Kids.\nStep 2: Calcola la percentuale di difetti.\nStep 3: Se > 5%, scrivi una bozza di reclamo.'"
            },
            {
                name: "LVL 3: THE ENGINEER",
                tech: "DELIMITERS & STRUCTURE",
                req: 2,
                dist: 600,
                wind: 1.5, // Windy!
                desc: "Il vento del caos soffia forte! Quando incolli dati sporchi o email lunghe, usa i delimitatori (###) per proteggere le istruzioni.",
                code: "PROMPT:\n'Analizza SOLO il testo contenuto tra ###.\n###\n[Incolla qui l'email confusa del fornitore]\n###\nEstrai: Data, Numero Ordine, SKU.'"
            },
            {
                name: "LVL 4: THE DIRECTOR",
                tech: "KEYWORDS & FORMATS",
                req: 3,
                dist: 700,
                wind: 0.5,
                desc: "Parla la lingua dell'AI. Usa KEYWORDS specifiche per forzare il formato dell'output. Non dire 'fammi vedere', dì 'Genera una Tabella'.",
                code: "PROMPT:\n'Analizza i dati di vendita.\nOUTPUT FORMAT: Crea una [TABLE] con colonne: Item, Qty, Trend.\nPoi genera un [PYTHON SCRIPT] per visualizzare il grafico.\nInfine, scrivi una sintesi stile [INFOGRAPHIC].'"
            }
        ];

        // --- INIT ---
        this.generateCrowd();
        this.bindEvents();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    bindEvents() {
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') this.handleInput();
        });
        this.canvas.addEventListener('mousedown', () => this.handleInput()); // Support mouse click too
    }

    generateCrowd() {
        this.crowdBanners = [];
        for (let i = 0; i < 8; i++) {
            this.crowdBanners.push({
                x: Math.random() * 900 + 30,
                y: 540 + Math.random() * 60,
                text: BANNERS[Math.floor(Math.random() * BANNERS.length)],
                color: Math.random() > 0.5 ? COLORS.orange : COLORS.white,
                offsetY: 0
            });
        }
    }

    startLevel(idx) {
        document.getElementById('startModal').style.display = 'none';
        document.getElementById('levelModal').style.display = 'none';
        this.levelIdx = idx;
        this.shotsMade = 0;
        this.updateHUD();
        this.resetShot();
    }

    resetShot() {
        this.state = 'AIM';
        this.ball.active = false;
        this.ball.rot = 0;
        this.power = 0;
        this.angle = 45;

        const lvl = this.levels[this.levelIdx];
        this.player.x = this.hoop.x - lvl.dist;
        
        // Reset Ball to Player hand
        this.ball.x = this.player.x + 40;
        this.ball.y = this.player.y - 20;

        // Set Wind
        this.wind = lvl.wind ? (Math.random() * lvl.wind - (lvl.wind/2)) : 0;
    }

    handleInput() {
        if (this.state === 'AIM') {
            this.state = 'POWER';
        } else if (this.state === 'POWER') {
            this.shoot();
        } else if (this.state === 'RESULT') {
            this.resetShot();
        }
    }

    shoot() {
        this.state = 'FLIGHT';
        this.ball.active = true;
        
        // Calc Physics
        const rad = (this.angle * Math.PI) / 180;
        const velocity = (this.power / 100) * 22 + 10; // Min 10, Max 32
        
        this.ball.vx = Math.cos(rad) * velocity;
        this.ball.vy = -Math.sin(rad) * velocity;
        
        // Spawn "POOF" particles at launch
        this.spawnParticles(this.ball.x, this.ball.y, 10, 'spark');
    }

    update() {
        // --- INPUT ANIMATION ---
        if (this.state === 'AIM') {
            this.angle += this.angleDir;
            if (this.angle > 80 || this.angle < 20) this.angleDir *= -1;
        }
        if (this.state === 'POWER') {
            this.power += this.powerDir;
            if (this.power > 100 || this.power < 5) this.powerDir *= -1;
        }

        // --- BALL PHYSICS ---
        if (this.state === 'FLIGHT' && this.ball.active) {
            this.ball.vy += 0.45; // Gravity
            this.ball.vx -= 0.01; // Air Drag
            this.ball.x += this.ball.vx + this.wind;
            this.ball.y += this.ball.vy;
            this.ball.rot += this.ball.vx * 0.1;

            // 1. Floor Collision
            if (this.ball.y > 550) {
                this.ball.y = 550;
                this.ball.vy *= -0.6; // Bounce
                this.ball.vx *= 0.8;
                if (Math.abs(this.ball.vy) < 1 && Math.abs(this.ball.vx) < 0.5) {
                    this.failShot("SHORT");
                }
            }

            // 2. Backboard Collision (Rect)
            const bbX = this.hoop.x + 40;
            if (this.ball.x > bbX && this.ball.x < bbX + 10 && 
                this.ball.y > this.hoop.y - 100 && this.ball.y < this.hoop.y) {
                this.ball.vx *= -0.5;
                this.shake = 5; // Screen shake
            }

            // 3. Rim/Hoop Collision (Magnetic Logic)
            const dx = this.ball.x - this.hoop.x;
            const dy = this.ball.y - this.hoop.y;
            const distSq = dx*dx + dy*dy;

            // If close and falling down
            if (distSq < 1500 && this.ball.vy > 0) {
                this.success();
            }

            // Out of bounds
            if (this.ball.x > this.width + 100) this.failShot("AIRBALL");
        }

        // --- PARTICLES & EFFECTS ---
        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });

        this.floaters.forEach((f, i) => {
            f.update();
            if (f.life <= 0) this.floaters.splice(i, 1);
        });

        // Crowd Animation (Idle bobbing)
        if (this.state === 'MENU' || this.state === 'AIM') {
            this.crowdBanners.forEach(b => {
                b.offsetY = Math.sin(Date.now() / 200 + b.x) * 3;
            });
        }

        // Screen Shake Decay
        if (this.shake > 0) {
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }
    }

    failShot(reason) {
        if (this.state === 'RESULT') return;
        this.state = 'RESULT';
        this.floaters.push(new Floater(reason === "SHORT" ? "TOO SHORT" : "AIRBALL", this.ball.x, this.ball.y - 50, 30, '#ff4444'));
        setTimeout(() => this.resetShot(), 1500);
    }

    success() {
        if (this.state === 'SUCCESS') return;
        this.state = 'SUCCESS';
        this.score += 250;
        this.shotsMade++;
        
        // FX Explosion
        this.spawnParticles(this.hoop.x, this.hoop.y, 40, 'confetti');
        this.floaters.push(new Floater(this.getPraiseWord(), this.hoop.x, this.hoop.y - 60, 40, COLORS.orange));
        this.shake = 10;

        this.updateHUD();

        setTimeout(() => {
            const lvl = this.levels[this.levelIdx];
            if (this.shotsMade >= lvl.req) {
                this.levelComplete();
            } else {
                this.resetShot();
            }
        }, 2000);
    }

    getPraiseWord() {
        const words = ["SWISH!", "PERFECT!", "OPTIMIZED!", "ENGINEERED!", "BOOM!"];
        return words[Math.floor(Math.random() * words.length)];
    }

    levelComplete() {
        const lvl = this.levels[this.levelIdx];
        document.getElementById('lvl-badge').innerText = lvl.tech;
        document.getElementById('lvl-desc').innerText = lvl.desc;
        document.getElementById('lvl-code').innerText = lvl.code;
        document.getElementById('levelModal').style.display = 'flex';
    }

    nextLevel() {
        if (this.levelIdx + 1 < this.levels.length) {
            this.startLevel(this.levelIdx + 1);
        } else {
            alert("TRAINING COMPLETED! You are now a Gemini Champion.");
            location.reload();
        }
    }

    spawnParticles(x, y, count, type) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, type));
        }
    }

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = this.score.toString().padStart(4, '0');
        const lvl = this.levels[this.levelIdx];
        document.getElementById('levelDisplay').innerText = `${lvl.name} [${this.shotsMade}/${lvl.req}]`;
    }

    // --- RENDER LOOP ---
    draw() {
        // Handle Camera Shake
        this.ctx.save();
        if (this.shake > 0) {
            const dx = (Math.random() - 0.5) * this.shake;
            const dy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(dx, dy);
        }

        this.ctx.clearRect(0, 0, this.width, this.height);

        // 1. SKY & CITY
        const grad = this.ctx.createLinearGradient(0, 0, 0, 600);
        grad.addColorStop(0, COLORS.skyTop);
        grad.addColorStop(1, COLORS.skyBot);
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw Berlin TV Tower (Silhouette)
        this.ctx.fillStyle = '#111';
        this.ctx.beginPath();
        this.ctx.arc(600, 250, 15, 0, Math.PI*2); // Sphere
        this.ctx.rect(596, 265, 8, 300); // Shaft
        this.ctx.rect(598, 150, 4, 100); // Antenna
        this.ctx.fill();

        // Distant Buildings
        for (let i = 0; i < 15; i++) {
            let h = 80 + Math.sin(i * 132) * 50;
            this.ctx.fillRect(i * 70, 600 - h, 60, h);
            // Windows
            this.ctx.fillStyle = Math.random() > 0.95 ? '#ffffaa' : '#222';
            this.ctx.fillRect(i*70 + 10, 600 - h + 10, 5, 5);
            this.ctx.fillStyle = '#111';
        }

        // 2. CROWD
        this.drawCrowd();

        // 3. ROOFTOP FLOOR
        this.ctx.fillStyle = COLORS.concrete;
        this.ctx.fillRect(0, 550, this.width, 90);
        
        // Grid Lines (Perspective)
        this.ctx.strokeStyle = COLORS.gridLines;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        for (let i = 0; i < this.width; i+= 100) {
            this.ctx.moveTo(i, 550);
            this.ctx.lineTo(i - (i-480)*0.5, 640);
        }
        this.ctx.moveTo(0, 550); this.ctx.lineTo(this.width, 550); // Horizon
        this.ctx.stroke();

        // 4. HOOP
        this.drawHoop();

        // 5. PLAYER (Zally)
        this.drawPlayer();

        // 6. BALL
        if (this.ball.active) this.drawBall();

        // 7. PARTICLES & UI
        this.particles.forEach(p => p.draw(this.ctx));
        this.floaters.forEach(f => f.draw(this.ctx));
        
        if (this.state === 'AIM' || this.state === 'POWER') this.drawAimUI();

        this.ctx.restore();
    }

    drawCrowd() {
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(0, 500, this.width, 50); // Wall
        
        this.crowdBanners.forEach(b => {
            const y = b.y + b.offsetY;
            // Stick
            this.ctx.strokeStyle = '#555';
            this.ctx.beginPath();
            this.ctx.moveTo(b.x, 550);
            this.ctx.lineTo(b.x, y);
            this.ctx.stroke();
            // Banner
            this.ctx.fillStyle = b.color;
            this.ctx.fillRect(b.x - 50, y - 25, 100, 25);
            // Text
            this.ctx.fillStyle = b.color === COLORS.white ? COLORS.orange : COLORS.white;
            this.ctx.font = "bold 10px 'Roboto Mono'";
            this.ctx.textAlign = "center";
            this.ctx.fillText(b.text, b.x, y - 10);
        });
    }

    drawHoop() {
        const x = this.hoop.x;
        const y = this.hoop.y;
        
        // Pole
        this.ctx.fillStyle = '#444';
        this.ctx.fillRect(x + 40, y, 15, 550 - y);
        
        // Backboard
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        this.ctx.fillRect(x + 30, y - 90, 10, 100);
        this.ctx.strokeRect(x + 30, y - 90, 10, 100);
        this.ctx.fillStyle = COLORS.orange;
        this.ctx.fillRect(x + 32, y - 60, 6, 40); // Target Box

        // Rim
        this.ctx.strokeStyle = COLORS.orange;
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.moveTo(x - 25, y); this.ctx.lineTo(x + 25, y);
        this.ctx.stroke();

        // Net
        this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(x - 25, y); this.ctx.lineTo(x - 10, y + 35);
        this.ctx.lineTo(x + 10, y + 35); this.ctx.lineTo(x + 25, y);
        this.ctx.stroke();
    }

    drawPlayer() {
        const x = this.player.x;
        const y = this.player.y;
        
        if (this.zallyLoaded) {
            this.ctx.save();
            this.ctx.translate(x + 40, y + 40);
            this.ctx.scale(-1, 1);
            this.ctx.drawImage(this.zallyImg, -40, -50, 80, 100);
            this.ctx.restore();
        } else {
            // Fallback
            this.ctx.fillStyle = COLORS.orange;
            this.ctx.fillRect(x, y, 50, 80);
            this.ctx.fillStyle = '#ffccaa';
            this.ctx.fillRect(x+10, y-20, 30, 30);
        }
    }

    drawBall() {
        this.ctx.save();
        this.ctx.translate(this.ball.x, this.ball.y);
        this.ctx.rotate(this.ball.rot);
        
        this.ctx.fillStyle = COLORS.orange;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, this.ball.r, 0, Math.PI*2);
        this.ctx.fill();
        
        // Stripes
        this.ctx.strokeStyle = 'black';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, -this.ball.r); this.ctx.lineTo(0, this.ball.r);
        this.ctx.stroke();
        
        this.ctx.restore();
    }

    drawAimUI() {
        const x = this.player.x + 40;
        const y = this.player.y - 10;
        const len = 100;
        const rad = (this.angle * Math.PI) / 180;

        // Trajectory Line
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        this.ctx.setLineDash([5, 5]);
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + Math.cos(rad) * len, y - Math.sin(rad) * len);
        this.ctx.stroke();
        this.ctx.setLineDash([]);

        // Power Bar
        if (this.state === 'POWER') {
            const barW = 80;
            const barH = 10;
            const pPct = this.power / 100;
            
            this.ctx.fillStyle = '#333';
            this.ctx.fillRect(x - 40, y - 60, barW, barH);
            
            // Gradient Color
            const r = pPct < 0.5 ? 255 : Math.floor(255 - (pPct * 2 - 1) * 255);
            const g = pPct > 0.5 ? 255 : Math.floor(pPct * 2 * 255);
            this.ctx.fillStyle = `rgb(${r},${g},0)`;
            
            this.ctx.fillRect(x - 40, y - 60, barW * pPct, barH);
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// Start Game
const game = new Game();

</script>
</body>
</html>
